an N-D Informal Matrix is one that grows combinatorically massively
as it gets bigger and one that will always support O(1) matrix addition.


(1.)
1-D matrix/2-D matrix calculations could in theory,
be faster than binary integer calculations past a very large number


Hypothesis: inf. mult. isn't more space effic. 
than regular binary addition to infinity?

## Reduction Proof

= | stands for Reduction.
| = | stands for Irreducible Reduction

## Long Handed Subtraction example

100 - 50 |=| x |=| 0 =| x + 50 =| 100 |=| x - 50 =| 50

## Reductive Algebra Group

1. x |=| x

2. x |=| 0

3. 1/0 |=| 0

note 5-5 = 0 = 4+5+6-4-5-6 = 0

H([[2,3],[3,2]](+\*)) = 576

lets examine[[2,3],[3,2]](+\*)

## Informal Set Subtraction and Simplification

if an nxn(+\*) matrix be allocated a numeric in another matrix,
then an nxn(nxn(+\*)) matrrix would still aloow for ordinary matrix operations
on top of the existing thinner matrix which fits perfectly as subset speed for
found numerics which minimize the computational bound of H to O(1)

ergo, this could lead to faster matrix multiplication algorithms
for most non-trivial computations

so informal number theory suggest matrices contain matrices within matrices

informal subtraction (trivial):

+>4 - +>2 = {-5,5} - {-3,3} = {-5,-4,0,4,5}

obviously using integer subtraction within informal calc. is commutative
same thing for division and subtraction, but informal subtraction
is not integer subtraction! (set closure)

thus,

+>0 - +>0 = {0}

Simplication(Informal Division) Proofs

Q: we said that +>4 meant a solution which means choice for elements in the set

we can quantify it into one number then do some operation probably just
multiplication again to the whole set as one operation to the whole set...

this means division is about multiplication by selection sorting H or maybe h
another conjector function similar to H in the same field of conjector funcs?

so, is it the func H or h which relates Simplification?

u suggest that h is the new function which relates higher dim informal matrices
to lower informal matrix spaces but not to integers!

so if simplification (/) were a real operation in informal numbers regardless
it'd have to send itself as a function from ->n +>x= -> ->1 +>x (n dim to 1 dim)

the example matrix multiplication is the first order of informal (simplification)

INFORMAL MATRIX SIMPLIFICATION ALGORITHM IN 1D:
------------[b1,b2,b3,b4,b5]
[a1, a2, a3, a4]------------

1D informal matrix simpl requires stacking matrices like this.

also, note:

1. x/0 |=| y |=| 0 |=| 0/x =| y |=| x*0 =| 0 ?

2. there are three simpl functions, (/-), (/+), (/\*)

calculating (/+) is the easiest one to calc

there are 6 2d axes to manage in this system in total

(-,/), (+,/), (_,/), (_,+), (-,+), (-,\*)

4-D -> 6-D extension:

+, -, \*, / are all formally defined operations in the informal number system

[+ := set add.,- := set subt.,* := set mult.,/ := simpl.]

so, (-,/), (+,/), (_,/), (_,+), (-,+), (-,_)
= (+,-,_),(+,-,/),(+,_,/),(-,_,/) => 4-D

so for 6-D we have

[1]:[(+,-,*),(+,-,/)]
[2]:[(+,-,*),(+,*,/)]
[3]:[(+,-,*),(-,*,/)]
[4]:[(+,-,/),(+,*,/)]
[5]:[(+,-,/),(-,*,/)]
[6]:[(+,*,/),(-,*,/)]

where for example we have the operator h then,

(+,-,\*) h (+,-,/) |=| (x,y,z) ?


conjector limit hypothesis:
H^inf(+>x + +>y) = (x+1) + (y+1) + 2(inf)
then, H^C(+>x + +>y) = (x+1) + (y+1) + 2(C)

so, assume conjector lim hyp is valid
idea: 
S(x)dx = (x^2/2) + C
why not,
S(x)dx = (x^2/2) + H(C)?

simple proof, perturbing a function to infinity
could mean that C could be infinity or
rather be an element of any number system

does this mean then that possibly,

T(C) is a function that sends to an inf num,

S(x)dx = (x^2/2) + H^inf(T(C)) ?
so,
S(x)dx = (x^2/2) + C + |T(C)|(inf) ?

R = |T(C)|(inf) = w(inf)
then,
S{x}dx^2 = S{ (x^2/2) + C + w(inf) }dx
= S{ (x^2/2) + C }dx + xw(inf)

integral hypothesis:
suppose every time you integrate you get a 
multiplicative infinity that expands the scope
of infinity for every calculation done up to
a limit to infinity

assume C is an irrational number such as pi,
infinitely many digits, then,

|T(C)| consequently should equal inf
so, |T(C)| = inf  iff  C is irrational

thus,
in that case

S(x)dx = (x^2/2) + C + (inf)^2

so, every amount of digit needed to represent
C amounts to a function with a lim to inf

lets say C = pi then, 
S(x)dx = (x^2/2) + pi + (inf)^2

this theory suggests, H^inf(T(pi)) = x + inf^2
where x is a real number what is T?

observation:
1. |(+>(x+1) * +>(x+1))| |=| |(+>x / +>x)

since,
1. +>2 * +>2 = {-9,-6,-4,-3,-2,-1,0,1,2,3,4,6,9}
2. +>1 / +>1 = {-2,-1,0,1,2, 0/-2, 0/-1 , 0/1 , 0/2 , -2/0 , -1/0 , 1/0, 2/0}

both sets have a cardinality of 13 so could
for ex, 1/0 be two values

the result R = |T(C)|(inf) or min|T(C)|(inf)
seems to make little sense except if array x is an el. of X (INF numbers)
is an infinite array in linear algebra because H^inf seems like something
that could be used somewhere completely specific and that to my opinion is
in fact having a number system which has a definite number after 1.
because 0 = {0} is the zero el. and +>0 =  {-1,0,1} is the unit element
correction: +>0 =  {-1,0,1} is not the unit element it is the first element
H(+>0) may send to 1


Corollary:
H^inf(+>x + +>y) = (x+1) + (y+1) + 2(inf)
then, H^C(+>x + +>y) = (x+1) + (y+1) + 2(C)

if H^inf(+>x + ...) then (x0+1) + ... + n(inf)
then it is possible that then we have,

for ex (x0+1) + ... = 12
then,
12 + n(inf) = 6*2 + n(inf)
so is it possible that we can enemurate amount of factors
for 12 this way some how then ?

# Completely Unproven Theory

theory,

mystery of how symbols labeled x/0 could have parity with inf. mult. |=|?

d/ix(x) = i + d/dx(x)/S(x)dx

(x+1)(y+1)/0 = d/ix S(multiply[1,k->inf]d^k/ix(x) * d^k/ix(y))

where d/ix S = i + S(x)dx/d/dx(x)

so (x+1)/0 = ?

it is possible this function could be telegraphic?, divergent and converges at the same time?

could that be because i could possibly only ever have a field of integers if we can modify d/ix ?

a complex function would be interesting if its imaginary field were restricted to integers
because this alone could be outpaced by the monotic function at every step k for some k->inf somewhere?

imagine saying a function is always getting negated so it is now it's negative counterpart.
could a function then say it could always be positive after being negated in a sequence?

that function would have to always grow larger with every step K. thats means will have always atleast
been able to double itself every step K which means the function creates atleast 
2x amount of itself of itself every step K.

imagine always being multiplied by larger and larger negative numbers continuously then always being negated
bt larger and larger negative numbers means if a function save itself from monotonically diverging towards
the negative numbers always then you can only have a function monotonically diverge positively then,
this should measure how much a function displaces amounts "of itself of itself" it is the fact that
i when i^2 = -1 could be expaned to i where i^3 = -1 and this would already mean that when i^2 = -1
it takes depositing i twice for i to be able to create a negative "telegraph",
this means that if you draw a function continously upwards like in signal graphs then the integral
between when the function wasn't negative is the area of the signal square wave of the function.

this means the functions in between negatives are always concave which means quickly all there is
a number before a line almost up and then spaces where there are discontinuities

but those discontinuaties also make a function which were ridiculously concave too if we graphed
its negation, somewhere in the middle is two values for a complex number exactly meaning that
complex number meaning if 1 was a complex value you could find two values for 1 that aren't
the same as -1 that means that the graph of y = x could defy the rules of cartesian planes
a graph of f(x) = x could mean x = f(x) then x = f(x) could be a circle.

if there is a circle where it means (1)x then there could be another circle that represents
2(x) but that circle would have to start at 2(x) and end at 3 or so because
the cartesian plane being graphed means 1 passing on x actually means one function passes by

so if a cartesian plane can only be graphed by counting in integers than it can be used to
count functions instead of variables.

q: how do you use regular math make a sequence which always goes from 0 to i to i^2
in that order to infinity?

the shape of spinors and how i suggest you can plot either (x,y) or (f(x),(x,y))
means to me that spinors are counted in i where i requires more degrees to turn i into -1
so that the folds of spinors mirrors the amount of functions that cannot overlap or
rather an amount of folds. imagine the unit circle centered at (1/2,1/2) then it would
start at 0 and end at one then think there is a unit circle centered at every integer away
from every 1/2 then that would make the whole graph be representable by two functions

hypothesis: then the point is to say eventually that then this system takes the integer before a dot
in the real number for ex. 1.22405215 would then be between 1 and 2 so 1.22 could mean x = 22 for a 
function bounded from [1,2] exactly! this concludes with the suggestion 1.22.44 could mean
that from [1,2] that we plot (f1(22.44),f2(22.44)) suggesting a three dot real number system.

the riemann hypotnuse is the part of the riemann sum that isn't included in calculus
because there are infinitely many squares in linear algebra.

experimental theory: an informal array could take H(+>x) to an integer
but an informal matrix could take H(+>x) to a real number possibly.

this way you can say other bases of dims in these matrices are expansions
of of the space between integers. meaning that every base change in 
a 2d matrix in this system takes the number calculated

to a real number or infinite expansions of spaces between real numbers

would this then be a real number or another construct to infxinf dims

proof.
the point of this number format is to originally
"destroy the unity of number set uniquness of integers"

the original puzzle for informal numbers is:
an infinite list of sanscript characters that never ever repeats
the same character twice in the entire list

a real number could then be if we took H to all rows

let +>x(n) be row n of matrix +>x

H(+>x(0)) + O(+>x(1)) + ..

could mean 1547 + O(71281) + O'2(12515) + ... + O'n(151548)
in a single case becase we could have

inf + O(inf) + O'2(inf) + ... + O'n(inf) ?

solve.

if a real number is calculated to be inf^2 if it was only
made of infinite squares then how can we say that inf^2 
has two cardinalities. in an empty space there is 0 space
this is not even a point, this is a belladurn.

in the first space we have infinity
in the second space we have inf^2 + i*inf
in the third space we have ((inf^2) + i*inf)^2

the point is that the first space is the empty space
is the point for an integer,
so a real number is a two integer space because
there is a . that seperates two integer spaces

so we have 512321.123213 then we also have

123214.21412421.21421214.124214.214124

there are 4 dots here in this example but that also means this
an amount of spaces above the space for a real number
so imagine allocating a dot is a new realer format at every
point

then 21323 is an int
then 213.213 is a real number
then 5215.2215.215215 is a complex number right? wrong?

521.213.213 is equal to fractional components of complex numbers so,

imagine now,

521.213.213 + i(521.213.213)

this simple complex number would now be infinitely confusable if
it could be a complex number but thats the point!

521.213.213 + i(521.213.213)

the fractional component 213 now adds to the same component
where i(521.213.213) used to be

before it became 0 because it now is the third element of the
numbers i!

so,

then,

some magical set of operators O,

521.213.213 + i(521.213.213) = 521.213 + iO(213) + i'O(521.213.213)

this would then require for example adding atleast

.213 to 521.213

adding .213.213 atleast to O(213)

to be able to push i'O(521.213.213) to then copy over the same way.

so then where does 3 dots come into play then?

so with 123214.21412421.21421214.124214

we now have two integer slots after the first so we could then 
stop there!

because with two integer slots after a real number we could
calculate the sides exapnsion in a riemann sum with two integers
that were derived from exactly informal numbers. that means
that the wrong conlcusion to make is this.

that 5 dots are needed to do this computation,

123214.21412421.21421214.124214.21421214.124214

the math for 5 dots is literally the same math but only
harder to do in every way possible.

because informal numbers means we have 

123214.21412421.21/4/21/214.1/24/21/4

this is why a 3 dot number system is more efficient to calculate
than a 5 dot number system, informal numbers are necessary to
understand that they are needed to solve the 5D problem
in an efficient amount of time on earth (NP?)

and maybe that might be because every dot creates another NP hardness
that NP hardness is harder than the amount of time our universe
would take to die. that means it's supposed to take about
that long to do before it would supposedly "die".
my opinion. 5 dots means that a 12D string theory is actually
the 18D string theory. we live in a 12D universe so 18D
math could be a higher dimension around physics here.

this means that the universe is 12D - in terms of string theory

there seems to be a space between towers measuerd
by the change in x which then goes to 0 at the same
time it squeezes the height between each riemann square
to each other. but that means the height difference between
the left riemann sum compared to the right riemann sum
integrate at different speeds. we have

lets say f(x) = x then at every riemann square the left
and right height differences would integrate at the
same constant. if we can say that then equates
to a difference in height of 1 for a square size of 1
(rise over run are the same) then we can actually start
to integrate the sides of riemann sum using integers
and informal numbers if instead of squeezing riemman sum
square size to 0 we could that calculation using integer
values for square sizes. that means that integration
could be done with a square size which would be the diff.
that you integrate by. normal integration uses 0.
but using a seperate formalution of 0 send to it by informality
it could be a different base for integrating height.
this means that squeezing happens where squeezing should happen

so if you had a function that needed smaller squares for ex after 1

if f(x) = { x if x<1 and x^2 if x>=1 }
then riemann squares would squeeze faster after x = 1 to normalize
the rise/run distributing along a real number

what is the integral of 1.2.5x then,

simple 1.2.0.5x^2 is the result of the integration.

that means integrating on time could be expressed otherwise

(1.2.5 + +>X) because if 1.2 + i is the point of complex numbers
then 1.2.5 + 1.2.5(+>X) is the point of informal numbers. so
this means while i is uncomplementary to its expansions
informal number are when are component to two decimal numbers

this is because .5 is just an informal number too.

this means (1.2.5 + 1.2.5(+>X)) + i(1.2.5 + 1.2.5(+>X))

would be a complex informal number because finding the second
pattern for combinatorical growth other i might be "dirac x"
or +d x or +> x, which i thought before.

this means that to add a new type of i in mather after i you
have to make the complex pattern again and add a . to the end
of every number that is just the new expansion.

so i is the number which takes 1 to 1.2 always. if you always
restrict your domain to integers you might also always find
shortcuts to integration without forcefully include the algebra
related to i calculus because the algebra related to +d might
be already a new +d calculus for itself then,

we could have, 

2. (1.2.5 + 1.2.5(+>X)) + i(1.2.5 + 1.2.5(+>X)) +d ((1.2.5 + 1.2.5(+>X)) + i(1.2.5 + 1.2.5(+>X)))

and this is also an informal number.

this means that

1. 521.213.213 + i(521.213.213) = 521.213 + iO(213) + i'O(521.213.213)

is the past math which takes you to two so,

so we have 

1.2.5 + i(1.2.5) = 1.2 + 5i + 
i'((1.2.5 + 1.2.5(+>X)) + i(1.2.5 + 1.2.5(+>X)) +d 
((1.2.5 + 1.2.5(+>X)) + i(1.2.5 + 1.2.5(+>X))))

so, 
1.2.5 + i(1.2.5) - 
i'((1.2.5 + 1.2.5(+>X)) + i(1.2.5 + 1.2.5(+>X)) +d 
((1.2.5 + 1.2.5(+>X)) + i(1.2.5 + 1.2.5(+>X))))

= 1.2 + 5i so what is i'*i then? i'' so that means

i'1.2.5 + i'1.2.5(+>X) + i''1.2.5 + i''1.2.5(+>X) +d 
i'1.2.5 + i'1.2.5(+>X) + i''1.2.5 + i''1.2.5(+>X)

so we have,

i'1.2.5 + i'1.2.5(+>X) +d i'1.2.5 + i'1.2.5(+>X) +
i''1.2.5 + i''1.2.5(+>X) +d i''1.2.5 + i''1.2.5(+>X)


this is the integer format for a real numbered informal number
it obeys all rules as x so

i'1.2.5 + i'1.2.5(+>X) +d i'1.2.5 + i'1.2.5(+>X) +
i''1.2.5 + i''1.2.5(+>X) +d i''1.2.5 + i''1.2.5(+>X)

could equal only an irrational number but that
means that you'd have to encode all 0s instead of
leaving blank information to assume.

lets say you had button with a func f()

and you only had one button and you pressed it many times

now imagine another function g() has a button

you can press the first and second button as many times as you want
for ex,

fgggggffffgffgfffggfgffgffgggffgf is a bunch of button presses

in a sequence one button is always pressed after another there
are no race conditions in this hypothetical

so then button h() does something weird h() switches button 1
to be g() and button 2 to be f().

so then that means fgggggffffgffgfffggfgffgffgggffgf is ok

but fgfgf h fgffgf is a sequence where we flipped f and g

so, 121 h 212 would then be then be 121121 there is a turing complete
language that can utilize this as machine code

there is only the option to now switch buttons with more buttons
in a way that is exactly defined so lets say button 4 is J()

then you have J() switches button 3 and button 2 then

fgfgf J h fgffgf

would then become for ex, 121223 = 121 J h 212!

so if we had a number system like one where

a = 0, b = 1, c = swap(a,b), d = swap(b,c), ...
then this swap math is turing complete, assumably

so, the func standardly applied to a writes 0 and 
the func for b writes 1 then swapping the func to write 
only by possibly swapping it with a func to swap specific 
slots means that only 2 letters in the alphabet will ever 
be assigned to a function which writes in the sequence 

a button is void function in pure math

f(x) is a function, f() is a button

if buttons a() and b() lead to buttons write0() write1() and swap0(), swap1(), ... , swapn() 
then this is the point of this math being about buttons only mapping to buttons purely

now imagine a() is (write 0) and b() is write(1) and c swaps a's action with b's action

a() is only a button because actions are numbered so 1() is unit function
in the action set and a() is the unit button in the button set

this is how you do the algebra
if 3() is actually swap(a,b) that means that 3() would be the first action
to nest every action after it within the action 3()

so the first logical step is to say,

we have a() b() d() a() c() b()

we have 1() 2() 4() a() c() b()

we have 1() 2() a() b() c()

we have 1() 2() 1() 2() c()

this is an invalid sequence then,

then, a() b() d() a() c() b() x()

will x() be a() b() or c() ?

1() 2() 4() a() c() b() c()

1() 2() a() b() c() b()

1() 2() 1() 2() 1()

seems x could be only a() or c()

so abdacbc = 01010 as expected.

possibly could this swap function describe this numeral?

i'1.2.5 + i'1.2.5(+>X) +d i'1.2.5 + i'1.2.5(+>X) +
i''1.2.5 + i''1.2.5(+>X) +d i''1.2.5 + i''1.2.5(+>X)

so imagine we only have a() b() c() and d() for 1() 2() 3() 4()

then how is this system a mapping to functional component mapping like this
if we said any part of this moving system had any parts to it'd mean that
discover d() or 4() would be the answer to the mystery.


so then we live in the real world where actions are only buttons then,

i' = ic()
i'' = id()

there are no more i than ic() and id()

this is the same system except that it has some way of computing it

iff, the order of operations literally moved themselves in order according
to this system depending on which you did first so does that mean
that already rewriting the system would've changed ic() and id(), no
that only made sense if +d didn't already break up ic() and id()
by being a replacement for your imagination of seperating ic() and id()
because once you encounter +d you know something changed already due
to a single action before hand so if i' is ic() then +d is an unkown
expression like i that could only be discovered by a guess.

so if ab d ac b c = 0 1 0 1 0 as expected.

i'1.2.5 + i'1.2.5(+>X) + i''1.2.5 + i''1.2.5(+>X) +d 
i'1.2.5 + i'1.2.5(+>X) + i''1.2.5 + i''1.2.5(+>X)

then you have,

a = i'1.2.5 + i'1.2.5(+>X)
b = i''1.2.5 + i''1.2.5(+>X)
c = i'1.2.5 + i'1.2.5(+>X)
d = i''1.2.5 + i''1.2.5(+>X)

yes, of course that means 

i'1.2.5 + i'1.2.5(+>X) 
+ i''1.2.5 + i''1.2.5(+>X) 
+ i'1.2.5 + i'1.2.5(+>X) 
+ i'1.2.5 + i'1.2.5(+>X)
+ i''1.2.5 + i''1.2.5(+>X) 
+ i'1.2.5 + i'1.2.5(+>X)

is equal to 1.2(+>5). :D

there are a few errors with plugging along with axiomatic patches

the fact is 1.2.0 is equal to 1.2 the real number so if 

1.2.1 could mean +d 1 then actually the whole point of the +d
anywhere in this system is to change everything after the second dot

so that means that the first two slots in this number system x.y.z
will always be compatible with the real numbers so

1.0.z * 1.2 = 1.2.z, the system then can be compromised into only
portions which contain the .z then we have 

ic()5 + ic()5(+>X) + id()5 + id()5(+>X) +d 
ic()5 + ic()5(+>X) + id()5 + id()5(+>X)

so whats the point? then , this is the best part!

ic()+>5 + ic()+>5(+>X) + id()+>5 + id()+>5(+>X) +d 
ic()+>5 + ic()+>5(+>X) + id()+>5 + id()+>5(+>X)

the pattern should change and it does sommetimes by two expansions

which means,
        |              |         |        
ic()+>5 + ic()+>5(+>X) + id()+>5 + id()+>5(+>X) +d 
ic()+>5 + ic()+>5(+>X) + id()+>5 + id()+>5(+>X)

ic()+>5 + id()+>5 +d ic()+>5(+>X) + id()+>5(+>X)
ic()+>5 + id()+>5 +d ic()+>5(+>X) + id()+>5(+>X)

then w have the true pattern of this system. through the wire system
where c() and d() are wires instead of action or buttons.

imagine taking a wire system like and putting it out in real life
it is the point of c() and d() because they are analog counterpart to actions
an action is made from wire to a button. every action has a wire to a button.
this is the same thing as having a button that pushes an action
imagine a button that was a fake of an action then c() and d() prove to me
that algebra is self-referential enough to never not require combinatorical
patterns as a humongous effort that is humanly achievable within saying order
of everthing matters

then the idea of this being a matrix isnt funny becase its composed of 4?

a. ic()+>5 + id()+>5 +d 
b. ic()+>5(+>X) + id()+>5(+>X)
c. ic()+>5 + id()+>5 +d 
d. ic()+>5(+>X) + id()+>5(+>X)

then maybe 
a()+>5 + ib()+>5 d()  ia()+>5 + ib()+>5 d()
ia()+>5c() + ib()+>5c()
ia()+>5c() + ib()+>5c()

is the correct way to comput x.y.(+>5) ?

a flag is a composite term for two termless functions a() and b() of any type
which down to the term level mean the exact same thing. so if you say

f() then i know you meant a() and b() so lets say then f() is now.
a() and b() but they do they a different function each once flagged

this is like say f(a()) = c() and f(b()) = d()
but also f(a()) = c() and f(b()) = c()

if it were a valid flag. an invalid flag is 
missing all of its cardinality because it could
always mean the same thing in deeper math

so obviously cant then say make

f() a() then mean a() b()

happen because then b() could be before a()

so if f() assigned a new term to a() then
we have f() a() = b() a() because f()
would signal that something

at the end its complicated to say a() could mean
two actions like write 0 and write 1 at the same time
this wouldn't ever make sense.

so a flag can only ever designate another wire
to be placed before a button

here is the system 
button, action, wire, flag

then a() b() mean are simply button hooked
up to actions 
1() and 2()
then those actions have wires so
a() -> 1() and b() -> 2()
then, a flag says

if f() could change a wire by
adding an action to it only previously
then f() could then morph wire g0: a() -> 1()
to then mean g1: a() -> 2() -> 1()

then we have two wires g0 and g1 connected by
a flag as the same button so we have,
f : g0: a() -> 1() , g1: a() -> 2() -> 1()

which means consequently that an action originally
intention always takes priority on its material state
 

b0 : f0 : w0 : a0[]
so,
b() : f() : w() : 1()

because f()  could mean its oringal meaning
of add the action 1() but w()
could perform action 1()

so you could push all 4 of these "buttons" and achieve
the same result then how could swap do this then

b0() : f0() : w0() : 1()
b1() : f1() : w1() : 2()

then simply calculating a system before the next is algebra
if you made f3() a flag in your system and that meant
f3 : g0: a() -> 1() , g1: a() -> 2() -> 1()

this flag would have to be swappable with both

f0() and f1() at some point meaning that required another wire to
create f3() so how did you take two flags and composite their
wires by using a buttons flag before another button

that means using flags are unsafe because then adding a flag
without closing will always be add computation before other
computation

so say we use f1() illegally then we have

f1() b() b() and now we have 1() 2() 1() 1() 2()

because then we need f1() b() b() f1() a()

to mean, 1() 2() 1() 1() 2() 1()

not, 

1() 2() 1() 1() 2() 1() 1()

if we said f1() b() b() a()

so then we can build a tiny system using only
the 4 systems said above in python that could 
encode informal addition


so if we had 4 sets we then have

F for flags,
B for buttons,
W for wires, and
A for actions

then,

B0() : F0() : W0 : A0
B1() : F1() : W1 : A1

where A0 is write 0 and A1 is write 1 then

how do we make a new rule?

F1() F0() B1 F0() F1()
will give us, a new rule every time F is used

so, this now gives us

101 where now our rules are 

B0() : F0() : W0 : A0
B1() : F1()F0()F1() : W1,W0W1,W1W0W1 : A1,A0,A1

then you have a system where 

B1() is now 101 so

B1() B1() is 101101 which is good

then if a sequnece 1110 is supposed to mean +>2

then how could 1110 + 1110 then mean 111 111 0

but then how could

11 100 0  + 111 000 000 0 then mean +>4 + +>8 which is

then 11 111 111 111 110 0 which is an invalid set.

you could think this system would work but it needs a modification

and that means the action to do A1() by itself is gone,
so how would you get it back then, by making memory for it
using flags on wires themselves

using a flag on a button makes the button forget its past rule
because it keeps it and always does it first in a decsion matrix,
using a flag on a wire means that then the wire you made
could be connected to a button if a button is pressed after it
that is newly defined so defining a wire to add to before pressing
a button is the only way to save a new rule for writing sequences
in front already 

now lets say we have a problem with flags the way they work,
an analog to flags could be faces then there is a problem

lets say we have 

B0() : F0() : W0 : A0
B1() : F1()F0()F1() : W1,W0W1,W1W0W1 : A1,A0,A1


then why would we how could we stack wires differently?

we have f: g0 -> 1, g1 -> 0 -> 1,

then we have f: , g0 -> 1 -> 0, g1 -> 1,

this is the problem is that flags and faces are different to each other

this means that my hypothesis is we live in a flag universe
where a faces universe would never support the action order
in the universe done by its simulation being always sequential

i think faces are the way our physics works where

f: , g0 -> 0 -> 1, g1 -> 0, is always facing actions
and that means f: g0 -> 0, g1 -> 1 -> 0, gets computed
before f: , g0 -> 0 -> 1, g1 -> 0, because if not
thermodynamics wouldn't work in this system

so then, 

f0: g0 -> 0, g1 -> 1 -> 0 would get computed first

f1: , g0 -> 0 -> 1, g1 -> 0 would get computed second

in a system where f0 is forward physics.
and f1 is negative physics.

regarding x.y.z numbers we have

x.y.z + w.e.r (antecedent)
x.y.z - w.e.r (subcedent)

x.y.z * w.e.r (expositive)
x.y.z / w.e.r (regressive)

result where x.y.z + w.e.r = x.y.z.z.z.w.e.r.r.r
but then you have x.y.z . z . z . w.e.r . r . r =

and c() is .z then, let a() = x.y 
and d() is .r then, let b() = w.e

so, a() c() c() c() b() d() d() d()
is the whole point of, doing the computation

here we have the whole point there are three steps
of computation to be measured for c() and d()
because they are the third component of x.y.z
but that means that c() is opening and closing after a()
correct so that means that c() opens a function to generate
.z and closes at the point of c()

so,

a() c() b() d() d() c() is valid and then we can say,
b() c() a() d() c() d() is also valid to rules of algebra

here we have a small amount of binary for,
antecedent and subcedent operations because its property of
commutativity would be reflexed instead

a() d() b() c() d() c() and
b() d() a() c() c() d()

because then this would be w.e.r + x.y.z above.

that means,

x.y.z + w.e.r = (x.y+w.e).(z/z+r) in f0
x.y.z + w.e.r = (x.y+w.e).(z+r/z) in f1

in the similar valid experiment.

why would z/z+r be the point of this ?

because if +> 2 / (+>5 + +>10)

hypothesis: then division in informal numbers requires two
denominators always so,

so, that means,
if 2/4 = (+>1)/(+>1 + +>1)

would then = (+>1) consequently

that isn't correct then,

4/2 = (+>1 + +>1)/(+>1) = (+>1)

so how does this clear up the mystery behind mult?

let mult, * := regular integer mult after transform to integer

so if 4/2 = (+>1 * +>1)/(+>1) = (+>1) then how does this work ?

so if 8/4 = (+>1 * +>1 * +>1)/(+>1 * +>1) you take two of the
same symbol off the top and bottom then? but that can be fixed
by thinking of the point here

if z+r/z = 8/4 = 2 and then z/z+r = 4/8 = 1/2 then how does 1/2
work then? so if 4/8 = (+>1 * +>1)/(+>1 * +>1 * +>1)
then 4/8 = (+>1)/(+>1 * +>1) = 2/4 so here is the shortcut!

so 8/4 = (+>1 * +>1 * +>1)/(+>1 * +>1) 
= (+>1 * +>1)/(+>1) then is the meaning of +>1

so that means that for everything to work then

+>1 = (+>1 * +>1)/(+>1)
+>2 = (+>2 * +>2)/(+>2)

somehow multiplication here can only be
the multiplication algorithm where

it just turns into an integer before multiplication
every time, that means the multiplication algorithm
correctly made is the only hard part about this system

so does 4*4 work here then

(+>1 + +>1)*(+>1 + +>1) = 16 = (4+>3) = 8(+>1) = 2*2*2(+>1)

which means that multiplication is just the a
shortcut for counting itself a number of times

so generally then,

(+>1 + +>1 + +>1)*(+>1 + +>1) = 12(+>1) = 3*2*2(+>1)

so multiplication would then require regular integer
multiplication as most of the shortcut math for
multiplication in the first case

but then does ?

+>0 = +>0 * +>0 / +>0 = 1*1 / 1 = 1/1 = 1

this just means eventually multiplication
could be found to be algebraically different
to addition meaning that if * worked like
it did in informal numbers where numbers are
mutliplied in the set like before then

let mult, * := +>x * +>y = {all num in x,y multiplied}

(+>1 + +>1) * +>1 / (+>1 + +>1) = +>1

 so then,

(+>2 + +>2) * +>1 / (+>2 + +>2) = +>1

which then gives us the rule for informal mult.

so then,

((+>1 + +>1) * +>1 / (+>1 + +>1)) * +>1 / (+>1 + +>1) = +>1

so then

+>1 * +>1 / (+>1 + +>1) = +>1 in a formal way.

((+>1 + +>1) * +>1 / (+>1 + +>1)) * +>1 / (+>1 + +>1) = +>1

also, 

(+>1 + +>1) * +>1 * +>1 /(+>1 + +>1) + (+>1 + +>1)  = +>1

(+>2 + +>2) * +>1 * +>1 /(+>2 + +>2) + (+>2 + +>2)  = +>2

# Possible Solutions

the end of this mess of axioms could be that

(+>0) * 1.25 = 1.25.(+>0) = 1.25

the whole point is that then (+>0)

could always mean 1 so then why not

sub in (+>0) everywhere?

1.25 + 2.50 = (+>0 * 1.25) + (+>0 * 2.50) = 3.75

(+>0 * 1.25) + (+>1 * 1.25) = 2.50.(+>0 + +>1/+>1)

then how does this work?